use std::{
    borrow::Cow,
    collections::HashMap,
    mem,
    num::{NonZeroU32, NonZeroU64},
};

use super::{LayerMask, LayerParams, LayerType};
use crate::{
    generate::{
        GenDisplacementsUniforms, GenHeightmapsUniforms, GenMaterialsUniforms, GenNormalsUniforms,
    },
    gpu_state::GpuState,
    terrain::quadtree::VNode,
};
use bytemuck::Pod;
use cgmath::Vector2;
use maplit::hashmap;
use std::convert::TryFrom;
use vec_map::VecMap;

pub(crate) trait GenerateTile: Send {
    /// Layers generated by this object. Zero means generate cannot operate for nodes of this level.
    fn outputs(&self, level: u8) -> LayerMask;
    /// Layers required to be present at `level` when generating a tile at `level`.
    fn peer_inputs(&self, level: u8) -> LayerMask;
    /// Layers required to be present at `level-1` when generating a tile at `level`.
    fn parent_inputs(&self, level: u8) -> LayerMask;
    /// Returns whether previously generated tiles from this generator are still valid.
    fn needs_refresh(&mut self) -> bool;
    /// Run the generator for `node`.
    fn generate(
        &mut self,
        device: &wgpu::Device,
        encoder: &mut wgpu::CommandEncoder,
        state: &GpuState,
        layers: &VecMap<LayerParams>,
        node: VNode,
        slot: usize,
        parent_slot: Option<usize>,
        output_mask: LayerMask,
        uniform_data: &mut Vec<u8>,
    );
}

struct ShaderGen<T, F: 'static + Send + Fn(VNode, usize, Option<usize>, LayerMask) -> T> {
    shader: rshader::ShaderSet,
    shader_validation: bool,
    pipeline: Option<wgpu::ComputePipeline>,
    dimensions: u32,
    peer_inputs: LayerMask,
    parent_inputs: LayerMask,
    outputs: LayerMask,
    /// Used instead of outputs for root nodes
    root_outputs: LayerMask,
    /// Used instead of peer_inputs for root nodes
    root_peer_inputs: LayerMask,
    blit_from_bc5_staging: Option<LayerType>,
    name: String,
    f: F,
}
impl<T: Pod, F: 'static + Send + Fn(VNode, usize, Option<usize>, LayerMask) -> T> GenerateTile
    for ShaderGen<T, F>
{
    fn outputs(&self, level: u8) -> LayerMask {
        if level > 0 {
            self.outputs
        } else {
            self.root_outputs
        }
    }
    fn peer_inputs(&self, level: u8) -> LayerMask {
        if level > 0 {
            self.peer_inputs
        } else {
            self.root_peer_inputs
        }
    }
    fn parent_inputs(&self, level: u8) -> LayerMask {
        if level > 0 {
            self.parent_inputs
        } else {
            LayerMask::empty()
        }
    }
    fn needs_refresh(&mut self) -> bool {
        if self.shader.refresh() {
            self.pipeline = None;
            true
        } else {
            false
        }
    }
    fn generate(
        &mut self,
        device: &wgpu::Device,
        encoder: &mut wgpu::CommandEncoder,
        state: &GpuState,
        layers: &VecMap<LayerParams>,
        node: VNode,
        slot: usize,
        parent_slot: Option<usize>,
        output_mask: LayerMask,
        uniform_data: &mut Vec<u8>,
    ) {
        let uniforms = (self.f)(node, slot, parent_slot, output_mask);

        assert!(std::mem::size_of::<T>() <= 256);
        let uniform_offset = uniform_data.len();
        uniform_data.extend_from_slice(bytemuck::bytes_of(&uniforms));
        uniform_data.resize(uniform_offset + 256, 0);

        let views_needed = self.outputs(node.level()) & self.parent_inputs(node.level());
        let mut image_views: HashMap<Cow<str>, _> = HashMap::new();
        if let Some(parent_slot) = parent_slot {
            for layer in layers.values().filter(|l| views_needed.contains_layer(l.layer_type)) {
                image_views.insert(
                    format!("{}_in", layer.layer_type.name()).into(),
                    state.tile_cache[layer.layer_type].0.create_view(
                        &wgpu::TextureViewDescriptor {
                            label: Some(&format!(
                                "view.{}[{}]",
                                layer.layer_type.name(),
                                parent_slot
                            )),
                            base_array_layer: parent_slot as u32,
                            array_layer_count: Some(NonZeroU32::new(1).unwrap()),
                            ..Default::default()
                        },
                    ),
                );
            }
        }
        for layer in layers.values().filter(|l| views_needed.contains_layer(l.layer_type)) {
            image_views.insert(
                format!("{}_out", layer.layer_type.name()).into(),
                state.tile_cache[layer.layer_type].0.create_view(&wgpu::TextureViewDescriptor {
                    label: Some(&format!("view.{}[{}]", layer.layer_type.name(), slot)),
                    base_array_layer: slot as u32,
                    array_layer_count: Some(NonZeroU32::new(1).unwrap()),
                    ..Default::default()
                }),
            );
        }

        let (bind_group, bind_group_layout) = state.bind_group_for_shader(
            device,
            &self.shader,
            hashmap!["ubo".into() => (false, wgpu::BindingResource::Buffer(wgpu::BufferBinding {
                buffer: &state.generate_uniforms,
                offset: uniform_offset as u64,
                size: Some(NonZeroU64::new(mem::size_of::<T>() as u64).unwrap()),
            }))],
            image_views.iter().map(|(n, v)| (n.clone(), v)).collect(),
            &format!("generate.{}", self.name),
        );

        if self.pipeline.is_none() {
            self.pipeline =
                Some(device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
                    layout: Some(&device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
                        bind_group_layouts: [&bind_group_layout][..].into(),
                        push_constant_ranges: &[],
                        label: None,
                    })),
                    module: &device.create_shader_module(&wgpu::ShaderModuleDescriptor {
                        label: Some(&format!("shader.generate.{}", self.name)),
                        source: wgpu::ShaderSource::SpirV(self.shader.compute().into()),
                        flags: if self.shader_validation {
                            wgpu::ShaderFlags::VALIDATION
                        } else {
                            wgpu::ShaderFlags::empty()
                        },
                    }),
                    entry_point: "main",
                    label: Some(&format!("pipeline.generate.{}", self.name)),
                }));
        }

        {
            let mut cpass =
                encoder.begin_compute_pass(&wgpu::ComputePassDescriptor { label: None });
            cpass.set_pipeline(&self.pipeline.as_ref().unwrap());
            cpass.set_bind_group(0, &bind_group, &[]);
            cpass.dispatch(self.dimensions, self.dimensions, 1);
        }

        if let Some(layer) = self.blit_from_bc5_staging {
            let resolution = layers[layer].texture_resolution;
            let resolution_blocks = (resolution + 3) / 4;
            let row_pitch = (resolution_blocks * 16 + 255) & !255;
            assert!(resolution % 4 == 0);
            encoder.copy_texture_to_buffer(
                wgpu::ImageCopyTexture {
                    texture: &state.bc5_staging.0,
                    mip_level: 0,
                    origin: wgpu::Origin3d::default(),
                },
                wgpu::ImageCopyBuffer {
                    buffer: &state.staging_buffer,
                    layout: wgpu::ImageDataLayout {
                        bytes_per_row: Some(NonZeroU32::new(row_pitch).unwrap()),
                        rows_per_image: None,
                        offset: 0,
                    },
                },
                wgpu::Extent3d {
                    width: resolution_blocks,
                    height: resolution_blocks,
                    depth_or_array_layers: 1,
                },
            );
            encoder.copy_buffer_to_texture(
                wgpu::ImageCopyBuffer {
                    buffer: &state.staging_buffer,
                    layout: wgpu::ImageDataLayout {
                        bytes_per_row: Some(NonZeroU32::new(row_pitch).unwrap()),
                        rows_per_image: Some(NonZeroU32::new(resolution).unwrap()),
                        offset: 0,
                    },
                },
                wgpu::ImageCopyTexture {
                    texture: &state.tile_cache[LayerType::Normals].0,
                    mip_level: 0,
                    origin: wgpu::Origin3d { x: 0, y: 0, z: slot as u32 },
                },
                wgpu::Extent3d { width: resolution, height: resolution, depth_or_array_layers: 1 },
            );
        }
    }
}

struct ShaderGenBuilder {
    name: String,
    dimensions: u32,
    shader: rshader::ShaderSource,
    peer_inputs: LayerMask,
    parent_inputs: LayerMask,
    outputs: LayerMask,
    root_outputs: Option<LayerMask>,
    root_peer_inputs: Option<LayerMask>,
    blit_from_bc5_staging: Option<LayerType>,
    shader_validation: bool,
}
impl ShaderGenBuilder {
    fn new(name: String, shader: rshader::ShaderSource) -> Self {
        Self {
            name,
            dimensions: 0,
            outputs: LayerMask::empty(),
            shader,
            peer_inputs: LayerMask::empty(),
            parent_inputs: LayerMask::empty(),
            root_outputs: None,
            root_peer_inputs: None,
            blit_from_bc5_staging: None,
            shader_validation: true,
        }
    }
    fn dimensions(mut self, dimensions: u32) -> Self {
        self.dimensions = dimensions;
        self
    }
    fn outputs(mut self, outputs: LayerMask) -> Self {
        self.outputs = outputs;
        self
    }
    fn root_outputs(mut self, root_outputs: LayerMask) -> Self {
        self.root_outputs = Some(root_outputs);
        self
    }
    fn root_peer_inputs(mut self, root_peer_inputs: LayerMask) -> Self {
        self.root_peer_inputs = Some(root_peer_inputs);
        self
    }
    fn peer_inputs(mut self, peer_inputs: LayerMask) -> Self {
        self.peer_inputs = peer_inputs;
        self
    }
    fn parent_inputs(mut self, parent_inputs: LayerMask) -> Self {
        self.parent_inputs = parent_inputs;
        self
    }
    fn blit_from_bc5_staging(mut self, layer: LayerType) -> Self {
        self.blit_from_bc5_staging = Some(layer);
        self
    }
    fn no_validate(mut self) -> Self {
        self.shader_validation = false;
        self
    }
    fn build<T: Pod, F: 'static + Send + Fn(VNode, usize, Option<usize>, LayerMask) -> T>(
        self,
        f: F,
    ) -> Box<dyn GenerateTile> {
        Box::new(ShaderGen {
            name: self.name,
            shader_validation: self.shader_validation,
            shader: rshader::ShaderSet::compute_only(self.shader).unwrap(),
            pipeline: None,
            outputs: self.outputs,
            peer_inputs: self.peer_inputs,
            parent_inputs: self.parent_inputs,
            dimensions: self.dimensions,
            root_outputs: self.root_outputs.unwrap_or(
                if self.parent_inputs == LayerMask::empty() {
                    self.outputs
                } else {
                    LayerMask::empty()
                },
            ),
            root_peer_inputs: self.root_peer_inputs.unwrap_or(self.peer_inputs),
            blit_from_bc5_staging: self.blit_from_bc5_staging,
            f,
        })
    }
}

pub(crate) fn generators(
    layers: &VecMap<LayerParams>,
    soft_float64: bool,
) -> Vec<Box<dyn GenerateTile>> {
    let heightmaps_resolution = layers[LayerType::Heightmaps].texture_resolution;
    let heightmaps_border = layers[LayerType::Heightmaps].texture_border_size;
    let displacements_resolution = layers[LayerType::Displacements].texture_resolution;
    let normals_resolution = layers[LayerType::Normals].texture_resolution;
    let normals_border = layers[LayerType::Normals].texture_border_size;
    let grass_canopy_resolution = layers[LayerType::GrassCanopy].texture_resolution;

    let grass_canopy_base_slot = 30
        + super::tile::SLOTS_PER_LEVEL as u32
            * (layers[LayerType::GrassCanopy].min_level - 2) as u32;

    vec![
        ShaderGenBuilder::new(
            "heightmaps".into(),
            rshader::shader_source!("../shaders", "gen-heightmaps.comp", "declarations.glsl", "hash.glsl"),
        )
        .outputs(LayerType::Heightmaps.bit_mask())
        .dimensions((heightmaps_resolution + 7) / 8)
        .parent_inputs(LayerType::Heightmaps.bit_mask())
        .no_validate() // validation doesn't support barrier() yet.
        .build(
            move |node: VNode,
                  slot: usize,
                  parent_slot: Option<usize>,
                  _|
                  -> GenHeightmapsUniforms {
                let (_parent, parent_index) = node.parent().expect("root node missing");
                let parent_offset = crate::terrain::quadtree::node::OFFSETS[parent_index as usize];
                let origin = [
                    heightmaps_border as i32 / 2,
                    heightmaps_resolution as i32 / 2 - heightmaps_border as i32 / 2,
                ];
                let spacing = node.aprox_side_length()
                    / (heightmaps_resolution - heightmaps_border * 2 - 1) as f32;
                let resolution = heightmaps_resolution - heightmaps_border * 2 - 1;
                let level_resolution = resolution << node.level();
                GenHeightmapsUniforms {
                    position: [
                        i32::try_from(node.x() as i64 * resolution as i64
                            - level_resolution as i64 / 2
                            - heightmaps_border as i64).unwrap(),
                        i32::try_from(node.y() as i64 * resolution as i64
                            - level_resolution as i64 / 2
                            - heightmaps_border as i64).unwrap(),
                    ],
                    origin: [origin[parent_offset.x as usize], origin[parent_offset.y as usize]],
                    spacing,
                    in_slot: parent_slot.unwrap() as i32,
                    out_slot: slot as i32,
                    level_resolution: level_resolution as i32,
                    face: node.face() as u32,
                }
            },
        ),
        ShaderGenBuilder::new(
            "displacements".into(),
            if soft_float64 {
                rshader::shader_source!(
                    "../shaders",
                    "declarations.glsl",
                    "softdouble.glsl",
                    "gen-displacements.comp";
                    "SOFT_DOUBLE" = "1"
                )
            } else {
                rshader::shader_source!("../shaders", "gen-displacements.comp", "declarations.glsl"; "SOFT_DOUBLE" = "0")
            },
        )
        .outputs(LayerType::Displacements.bit_mask())
        .root_outputs(LayerType::Displacements.bit_mask())
        .dimensions((displacements_resolution + 7) / 8)
        .parent_inputs(LayerType::Heightmaps.bit_mask())
        .root_peer_inputs(LayerType::Heightmaps.bit_mask())
        .no_validate() // shaderFloat64 causes validation errors
        .build(
            move |node: VNode,
                  slot: usize,
                  parent_slot: Option<usize>,
                  _|
                  -> GenDisplacementsUniforms {
                let base_stride = (heightmaps_resolution - heightmaps_border * 2 - 1)
                    / (displacements_resolution - 1);
                let (offset, stride) = match parent_slot {
                    Some(_) => (Vector2::new(node.x() & 1, node.y() & 1), base_stride / 2),
                    None => (Vector2::new(0, 0), base_stride),
                };
                let world_center = node.center_wspace();
                let resolution = displacements_resolution - 1;
                let level_resolution = resolution << node.level();
                GenDisplacementsUniforms {
                    node_center: world_center.into(),
                    origin: [
                        (heightmaps_border
                            + (heightmaps_resolution - heightmaps_border * 2 - 1) * offset.x / 2)
                            as i32,
                        (heightmaps_border
                            + (heightmaps_resolution - heightmaps_border * 2 - 1) * offset.y / 2)
                            as i32,
                    ],
                    stride: stride as i32,
                    displacements_slot: slot as i32,
                    heightmaps_slot: parent_slot.unwrap_or(slot) as i32,
                    position: [
                        i32::try_from(node.x() as i64 * resolution as i64 - level_resolution as i64 / 2).unwrap(),
                        i32::try_from(node.y() as i64 * resolution as i64 - level_resolution as i64 / 2).unwrap(),
                    ],
                    face: node.face() as i32,
                    level_resolution,
                    padding0: 0.0,
                }
            },
        ),
        ShaderGenBuilder::new(
            "root-normals".into(),
            rshader::shader_source!("../shaders", "gen-root-normals.comp", "declarations.glsl", "hash.glsl"),
        )
        .root_outputs(LayerType::Normals.bit_mask())
        .dimensions((normals_resolution + 3) / 4)
        .peer_inputs(LayerType::Heightmaps.bit_mask())
        .blit_from_bc5_staging(LayerType::Normals)
        .no_validate() // validation doesn't support barrier() yet.
        .build(move |node: VNode, slot: usize, _, _| -> GenNormalsUniforms {
            let spacing =
                node.aprox_side_length() / (normals_resolution - normals_border * 2) as f32;

            GenNormalsUniforms {
                heightmaps_origin: [
                    (heightmaps_border - normals_border) as i32,
                    (heightmaps_border - normals_border) as i32,
                ],
                spacing,
                heightmaps_slot: slot as i32,
                normals_slot: slot as i32,
                padding: [0.0; 3],
            }
        }),
        ShaderGenBuilder::new(
            "materials".into(),
            rshader::shader_source!("../shaders", "gen-materials.comp", "declarations.glsl", "hash.glsl"),
        )
        .outputs(LayerType::Normals.bit_mask() | LayerType::Albedo.bit_mask())
        .dimensions((normals_resolution + 3) / 4)
        .parent_inputs(LayerType::Albedo.bit_mask())
        .peer_inputs(LayerType::Heightmaps.bit_mask())
        .blit_from_bc5_staging(LayerType::Normals)
        .no_validate() // validation doesn't support barrier() yet.
        .build(
            move |node: VNode,
                  slot: usize,
                  parent_slot: Option<usize>,
                  output_mask: LayerMask|
                  -> GenMaterialsUniforms {
                let spacing =
                    node.aprox_side_length() / (normals_resolution - normals_border * 2) as f32;

                let albedo_slot =
                    if output_mask.contains_layer(LayerType::Albedo) { slot as i32 } else { -1 };

                let parent_index = node.parent().unwrap().1;

                let resolution = heightmaps_resolution - heightmaps_border * 2 - 1;
                let level_resolution = resolution << node.level();
                GenMaterialsUniforms {
                    position: [
                        i32::try_from(node.x() as i64 * resolution as i64
                            - level_resolution as i64 / 2
                            - heightmaps_border as i64).unwrap(),
                        i32::try_from(node.y() as i64 * resolution as i64
                            - level_resolution as i64 / 2
                            - heightmaps_border as i64).unwrap(),
                    ],
                    level_resolution,
                    heightmaps_origin: [
                        (heightmaps_border - normals_border) as i32,
                        (heightmaps_border - normals_border) as i32,
                    ],
                    spacing,
                    heightmaps_slot: slot as i32,
                    normals_slot: slot as i32,
                    albedo_slot,
                    parent_slot: parent_slot.map(|s| s as i32).unwrap_or(-1),
                    parent_origin: [
                        if parent_index % 2 == 0 {
                            normals_border / 2
                        } else {
                            (normals_resolution - normals_border) / 2
                        },
                        if parent_index / 2 == 0 {
                            normals_border / 2
                        } else {
                            (normals_resolution - normals_border) / 2
                        },
                    ],
                    level: node.level() as u32,
                }
            },
        ),
        ShaderGenBuilder::new(
            "grass-canopy".into(),
            rshader::shader_source!("../shaders", "gen-grass-canopy.comp", "declarations.glsl", "hash.glsl"),
        )
        .outputs(LayerType::GrassCanopy.bit_mask())
        .dimensions((grass_canopy_resolution + 7) / 8)
        .peer_inputs(LayerType::Normals.bit_mask())
        .no_validate()
        .build(move |node: VNode, slot: usize, _, _| -> [u32; 2] {
            assert_eq!(node.level(), VNode::LEVEL_CELL_1M);
            [slot as u32, slot as u32 - grass_canopy_base_slot]
        })
    ]
}
