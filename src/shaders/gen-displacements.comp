#version 450 core

layout(local_size_x = 8, local_size_y = 8) in;

#include "declarations.glsl"


layout(binding = 0) uniform UniformBlock {
    int slot;
} ubo;
layout(binding = 1) uniform texture2DArray heightmaps;
layout(binding = 2) uniform texture2DArray ellipsoid;
layout(rgba32f, binding = 3) writeonly uniform image2DArray displacements;
layout(set = 0, binding = 4, std430) readonly buffer NodeSlots {
	Node nodes[];
};
layout(set = 0, binding = 5) uniform sampler linear;

const uint DISPLACEMENTS_RESOLUTION = 64;

const float A = 6378137.0;
const float B = 6356752.314245;

void main() {
    if (max(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y) > DISPLACEMENTS_RESOLUTION)
        return;

    Node node = nodes[ubo.slot];

    float height = extract_height(textureLod(sampler2DArray(heightmaps, linear),
        vec3(node.layer_origins[HEIGHTMAPS_LAYER] + vec2(gl_GlobalInvocationID) / float(DISPLACEMENTS_RESOLUTION) * node.layer_ratios[HEIGHTMAPS_LAYER], node.layer_slots[HEIGHTMAPS_LAYER]), 0).x);
    height = max(height, 0.0);

    vec3 ellipsoid_point = texelFetch(ellipsoid, ivec3(gl_GlobalInvocationID.xy, ubo.slot), 0).xyz;
    vec3 position = ellipsoid_point + node.node_center;

    float latitude = atan(position.z * (A*A / B*B), length(position.xy));
    float longitude = atan(position.y, position.x);
    vec3 normal = vec3(
        cos(latitude) * cos(longitude),
        cos(latitude) * sin(longitude),
        sin(latitude)
    );

    ivec3 pos = ivec3(gl_GlobalInvocationID.xy, ubo.slot);
    imageStore(displacements, pos, vec4(ellipsoid_point + normal * height, 0.0));
}