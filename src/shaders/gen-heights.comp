#line 2

layout(local_size_x = 1, local_size_y = 1) in;

layout(binding = 0) uniform UniformBlock {
    vec2 position;
	float base_heights_spacing;
	float spacing;
} ubo;

layout(set = 0, binding = 1) uniform texture2D base_heights;
layout(rgba32f, binding = 2) uniform image2D heights_staging;
layout(rg8, binding = 3) uniform image2D normals_staging;

layout(set = 0, binding = 4) uniform sampler linear;
layout(set = 0, binding = 5) uniform sampler linear_wrap;
layout(set = 0, binding = 6) uniform texture2D noise;

vec2 cubic(vec4 f, float t)
{
	vec4 a = vec4(dot(f, vec4(-0.5, 1.5, -1.5, 0.5)),
				  dot(f, vec4(1.0, -2.5, 2.0, -0.5)),
				  dot(f, vec4(-0.5, 0.0, 0.5, 0.0)),
				  f.y);

	float v = a.x * t*t*t
		+ a.y * t*t
		+ a.z * t
		+ a.w;

	float dv = 3.0*a.x*t*t + 2.0*a.y*t + a.z;

	return vec2(v, dv);
}

void main() {
	vec2 position = ubo.position
		+ vec2(gl_GlobalInvocationID.xy) * ubo.spacing;

	vec2 texsize = vec2(textureSize(base_heights, 0));
	vec2 texcoord = vec2(0.5) + position / (texsize * ubo.base_heights_spacing);
	vec2 t = fract(texcoord * texsize + vec2(0.5));

	//            x=0      |      x=1
	//     +-------+-------+-------+-------+
	//     | t00.w | t00.z | t10.w | t10.z |
	// y=0 +-------+-------+-------+-------+
	//     | t00.x | t00.y | t10.x | t10.y |
	// --- +-------+-------+-------+-------+
	//     | t01.w | t01.z | t11.w | t11.z |
	// y=1 +-------+-------+-------+-------+
	//     | t01.x | t01.y | t11.x | t11.y |
	//     +-------+-------+-------+-------+
	vec4 t00 = textureGatherOffset(sampler2D(base_heights, linear), texcoord, ivec2(-1,-1));
	vec4 t10 = textureGatherOffset(sampler2D(base_heights, linear), texcoord, ivec2(1,-1));
	vec4 t01 = textureGatherOffset(sampler2D(base_heights, linear), texcoord, ivec2(-1,1));
	vec4 t11 = textureGatherOffset(sampler2D(base_heights, linear), texcoord, ivec2(1,1));

	// See: https://www.ece.mcmaster.ca/~xwu/interp_1.pdf
	mat4 Binv = mat4(-1.0/6, 0.5, -1.0/3, 0,
					 0.5,     -1,   -0.5, 1,
					 -0.5,   0.5,      1, 0,
					 1.0/6,  0.0, -1.0/6, 0);
	mat4 F = mat4(t00.w, t00.z, t10.w, t10.z,
				  t00.x, t00.y, t10.x, t10.y,
				  t01.w, t01.z, t11.w, t11.z,
				  t01.x, t01.y, t11.x, t11.y);
	mat4 M = Binv * F * transpose(Binv);

	vec4 vx = vec4(t.x*t.x*t.x, t.x*t.x, t.x, 1.0);
	vec4 vy = vec4(t.y*t.y*t.y, t.y*t.y, t.y, 1.0);
	float f = dot(vx * M, vy);

	vec4 dx_vx = vec4(t.x*t.x, t.x, 1, 1) * vec4(3,2,1,0);
	vec4 dy_vy = vec4(3.0*t.y*t.y, 2.0*t.y, 1.0, 0.0);
	float dx = dot(dx_vx * M, vy) / ubo.base_heights_spacing;
	float dy = dot(vx * M, dy_vy) / ubo.base_heights_spacing;
	float dxdy = dot(dx_vx * M, dy_vy); // TODO: what scaling goes here?

	float slope = length(vec2(dx, dy));

	float n = 0;
	for(int i = 0; i < 8; i++) {
		float weight = exp2(i) * 0.5;
		float scale = exp2(i) * 256.0;
		n += weight * (texture(sampler2D(noise, linear_wrap), position/scale).x - .5);
	}
	// float n1 = texture(sampler2D(noise, linear_wrap), position/5000).x-0.5;
	// float n2 = texture(sampler2D(noise, linear_wrap), position/10000).x-0.5;
	// float n3 = texture(sampler2D(noise, linear_wrap), position/20000).x-0.5;
	// float n4 = texture(sampler2D(noise, linear_wrap), position/40000).x-0.5;
	// float n =  n4 * 40 + n3*20 + n2*10;
	vec4 out_height = vec4(0.0, f + n * mix(.3, 1, smoothstep(0.2, 0.5, slope)), 0.0, 0.0);

	// out_height.y = dx * 200;
	imageStore(heights_staging, ivec2(gl_GlobalInvocationID.xy), out_height);
}
