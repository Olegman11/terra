#version 450 core
#include "declarations.glsl"
#include "hash.glsl"

layout(local_size_x = 4, local_size_y = 4) in;

layout(binding = 0) uniform UniformBlock {
	ivec2 heightmaps_origin;
	ivec2 parent_origin;
	int heightmaps_slot;
	int normals_slot;
	int albedo_slot;
	int parent_slot;
	float spacing;
	uint level;
	ivec2 position;
	uint level_resolution;
} ubo;

layout(binding = 1) uniform utexture2DArray heightmaps;
layout(rg8, binding = 2) writeonly uniform image2DArray normals;

layout(binding = 3) uniform texture2D albedo_in;
layout(rgba8, binding = 4) writeonly uniform image2D albedo_out;

layout(set = 0, binding = 5) uniform texture2D noise;
layout(set = 0, binding = 6) uniform sampler linear_wrap;

shared vec2 group_normals[16];

void main() {
	ivec3 in_pos = ivec3(gl_GlobalInvocationID.xy + ubo.heightmaps_origin, ubo.heightmaps_slot);
	ivec2 out_pos = ivec2(gl_GlobalInvocationID.xy);

	uint e00 = texelFetch(heightmaps, in_pos, 0).x;
	uint e10 = texelFetch(heightmaps, in_pos + ivec3(1,0,0), 0).x;
	uint e01 = texelFetch(heightmaps, in_pos + ivec3(0,1,0), 0).x;
	uint e11 = texelFetch(heightmaps, in_pos + ivec3(1,1,0), 0).x;

	bool is_water = dot((uvec4(e00, e10, e01, e11) & uvec4(0x800000)) >> 23, uvec4(1)) > 2;

	float h00 = extract_height(e00);
	float h10 = extract_height(e10);
	float h01 = extract_height(e01);
	float h11 = extract_height(e11);

	vec3 normal = vec3(0,1,0);
	if (!is_water) {
		normal = vec3(h10 + h11 - h00 - h01,
						2.0 * ubo.spacing,
						-1.0 * (h01 + h11 - h00 - h10));
		normal = normalize(normal);
	}

	vec4 noise_value = vec4(0.5);//texture(sampler2D(noise, linear_wrap), vec2(world_pos.xy*.0001));

	vec4 albedo_roughness = vec4(.011, .03, .003, 0.7);
	float rock = 1-smoothstep(0.80, .95, normal.y);

	float grass_fraction = mix(0, .3, smoothstep(0.95, 1, normal.y));
	float grass = step(grass_fraction, dot(noise_value, vec4(.25)));
	albedo_roughness.rgb = mix(vec3(.03,.02,0), vec3(0,.1,0), grass);

	albedo_roughness.rgb = mix(albedo_roughness.rgb, vec3(0.02), rock);

	if (ubo.parent_slot >= 0) {
		vec2 nv = guassian_random(gl_GlobalInvocationID.xy);
		ivec2 offset = clamp(ivec2(round(nv)), ivec2(-1), ivec2(1));
		vec4 p = texelFetch(albedo_in, ivec2(ubo.parent_origin + (out_pos+offset)/2), 0);

		// HACK: We want to avoid blending in water texels onto the land. Since those texels are 
		// known to have low roughness, we can filter them with this check. If the lookup fails,
		// we use albedo and roughness values for sand.
		if (p.a > 0.5) {
			albedo_roughness = p;
		} else {
			albedo_roughness = vec4(.2, .2, .15, .8);
		}
	}

	if (is_water) {
		albedo_roughness.a = 0.1;
		float negative_depth = min(h00 + h10 + h01 + h11, 0);
		albedo_roughness.rgb = mix(vec3(0,.03,.2), albedo_roughness.rgb, exp(negative_depth * vec3(5,.5,.5)));
	}

	imageStore(normals, ivec3(out_pos, ubo.normals_slot), vec4(normal.xz*0.5+0.5, 0.0, 0.0));
	if (ubo.albedo_slot >= 0)
		imageStore(albedo_out, out_pos, albedo_roughness);
}
